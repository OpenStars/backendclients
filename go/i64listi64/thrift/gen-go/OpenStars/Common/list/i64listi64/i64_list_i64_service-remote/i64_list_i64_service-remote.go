// Autogenerated by Thrift Compiler (0.11.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package main

import (
        "context"
        "flag"
        "fmt"
        "math"
        "net"
        "net/url"
        "os"
        "strconv"
        "strings"
        "git.apache.org/thrift.git/lib/go/thrift"
        "OpenStars/Common/list/i64listi64"
)


func Usage() {
  fmt.Fprintln(os.Stderr, "Usage of ", os.Args[0], " [-h host:port] [-u url] [-f[ramed]] function [arg1 [arg2...]]:")
  flag.PrintDefaults()
  fmt.Fprintln(os.Stderr, "\nFunctions:")
  fmt.Fprintln(os.Stderr, "  i32 count(TKey key)")
  fmt.Fprintln(os.Stderr, "  bool existed(TKey key, TEntry entry)")
  fmt.Fprintln(os.Stderr, "  TEntryList getListAll(TKey key)")
  fmt.Fprintln(os.Stderr, "  TEntryList getAll(TKey key)")
  fmt.Fprintln(os.Stderr, "  TEntryList getSlice(TKey key, i32 start, i32 length)")
  fmt.Fprintln(os.Stderr, "  TEntryList getSliceFromEntry(TKey key, TEntry entryStart, i32 length)")
  fmt.Fprintln(os.Stderr, "  TEntryList getSliceFromId(TKey key, TEntry entryStart, i32 length)")
  fmt.Fprintln(os.Stderr, "  TEntryList getSliceReverse(TKey key, i32 start, i32 length)")
  fmt.Fprintln(os.Stderr, "  TEntryList getSliceFromEntryReverse(TKey key, TEntry entryStart, i32 length)")
  fmt.Fprintln(os.Stderr, "  TEntryList getSliceFromIdReverse(TKey key, TEntry entryStart, i32 length)")
  fmt.Fprintln(os.Stderr, "  bool put(TKey key, TEntry entry)")
  fmt.Fprintln(os.Stderr, "  bool putValue(TKey key, TValue value)")
  fmt.Fprintln(os.Stderr, "  bool putList(TKey key, TEntryList entryList)")
  fmt.Fprintln(os.Stderr, "  bool insert(TKey key, TEntry entry)")
  fmt.Fprintln(os.Stderr, "  bool insertAt(TKey key, TEntry entry, i32 index)")
  fmt.Fprintln(os.Stderr, "  bool remove(TKey key, TEntry entry)")
  fmt.Fprintln(os.Stderr, "  bool removeAt(TKey key, i32 index)")
  fmt.Fprintln(os.Stderr, "  bool bumpUp(TKey key, TEntry entry)")
  fmt.Fprintln(os.Stderr, "  bool removeList(TKey key, TEntryList entryList)")
  fmt.Fprintln(os.Stderr, "  void clearData(TKey key)")
  fmt.Fprintln(os.Stderr, "  TEntry split(TKey oldKey, TKey newKey, i32 origLength)")
  fmt.Fprintln(os.Stderr, "   multiCount(TKeyList keyList)")
  fmt.Fprintln(os.Stderr, "   multiExisted(TKeyList keyList, TEntry entry)")
  fmt.Fprintln(os.Stderr, "   multiGetListAll(TKeyList keyList)")
  fmt.Fprintln(os.Stderr, "   multiGetSlice(TKeyList keyList, i32 start, i32 length)")
  fmt.Fprintln(os.Stderr, "   multiGetSliceReverse(TKeyList keyList, i32 start, i32 length)")
  fmt.Fprintln(os.Stderr, "   multiPut(TKeyList keyList, TEntry entry)")
  fmt.Fprintln(os.Stderr, "  void put_ow(TKey key, TEntry entry)")
  fmt.Fprintln(os.Stderr, "  void putMultiKey_ow(TKeyList uidList, TEntry entry)")
  fmt.Fprintln(os.Stderr, "  void remove_ow(TKey key, TEntry entry)")
  fmt.Fprintln(os.Stderr)
  os.Exit(0)
}

func main() {
  flag.Usage = Usage
  var host string
  var port int
  var protocol string
  var urlString string
  var framed bool
  var useHttp bool
  var parsedUrl *url.URL
  var trans thrift.TTransport
  _ = strconv.Atoi
  _ = math.Abs
  flag.Usage = Usage
  flag.StringVar(&host, "h", "localhost", "Specify host and port")
  flag.IntVar(&port, "p", 9090, "Specify port")
  flag.StringVar(&protocol, "P", "binary", "Specify the protocol (binary, compact, simplejson, json)")
  flag.StringVar(&urlString, "u", "", "Specify the url")
  flag.BoolVar(&framed, "framed", false, "Use framed transport")
  flag.BoolVar(&useHttp, "http", false, "Use http")
  flag.Parse()
  
  if len(urlString) > 0 {
    var err error
    parsedUrl, err = url.Parse(urlString)
    if err != nil {
      fmt.Fprintln(os.Stderr, "Error parsing URL: ", err)
      flag.Usage()
    }
    host = parsedUrl.Host
    useHttp = len(parsedUrl.Scheme) <= 0 || parsedUrl.Scheme == "http"
  } else if useHttp {
    _, err := url.Parse(fmt.Sprint("http://", host, ":", port))
    if err != nil {
      fmt.Fprintln(os.Stderr, "Error parsing URL: ", err)
      flag.Usage()
    }
  }
  
  cmd := flag.Arg(0)
  var err error
  if useHttp {
    trans, err = thrift.NewTHttpClient(parsedUrl.String())
  } else {
    portStr := fmt.Sprint(port)
    if strings.Contains(host, ":") {
           host, portStr, err = net.SplitHostPort(host)
           if err != nil {
                   fmt.Fprintln(os.Stderr, "error with host:", err)
                   os.Exit(1)
           }
    }
    trans, err = thrift.NewTSocket(net.JoinHostPort(host, portStr))
    if err != nil {
      fmt.Fprintln(os.Stderr, "error resolving address:", err)
      os.Exit(1)
    }
    if framed {
      trans = thrift.NewTFramedTransport(trans)
    }
  }
  if err != nil {
    fmt.Fprintln(os.Stderr, "Error creating transport", err)
    os.Exit(1)
  }
  defer trans.Close()
  var protocolFactory thrift.TProtocolFactory
  switch protocol {
  case "compact":
    protocolFactory = thrift.NewTCompactProtocolFactory()
    break
  case "simplejson":
    protocolFactory = thrift.NewTSimpleJSONProtocolFactory()
    break
  case "json":
    protocolFactory = thrift.NewTJSONProtocolFactory()
    break
  case "binary", "":
    protocolFactory = thrift.NewTBinaryProtocolFactoryDefault()
    break
  default:
    fmt.Fprintln(os.Stderr, "Invalid protocol specified: ", protocol)
    Usage()
    os.Exit(1)
  }
  iprot := protocolFactory.GetProtocol(trans)
  oprot := protocolFactory.GetProtocol(trans)
  client := i64listi64.NewI64ListI64ServiceClient(thrift.NewTStandardClient(iprot, oprot))
  if err := trans.Open(); err != nil {
    fmt.Fprintln(os.Stderr, "Error opening socket to ", host, ":", port, " ", err)
    os.Exit(1)
  }
  
  switch cmd {
  case "count":
    if flag.NArg() - 1 != 1 {
      fmt.Fprintln(os.Stderr, "Count requires 1 args")
      flag.Usage()
    }
    argvalue0, err92 := (strconv.ParseInt(flag.Arg(1), 10, 64))
    if err92 != nil {
      Usage()
      return
    }
    value0 := i64listi64.TKey(argvalue0)
    fmt.Print(client.Count(context.Background(), value0))
    fmt.Print("\n")
    break
  case "existed":
    if flag.NArg() - 1 != 2 {
      fmt.Fprintln(os.Stderr, "Existed requires 2 args")
      flag.Usage()
    }
    argvalue0, err93 := (strconv.ParseInt(flag.Arg(1), 10, 64))
    if err93 != nil {
      Usage()
      return
    }
    value0 := i64listi64.TKey(argvalue0)
    argvalue1, err94 := (strconv.ParseInt(flag.Arg(2), 10, 64))
    if err94 != nil {
      Usage()
      return
    }
    value1 := i64listi64.TEntry(argvalue1)
    fmt.Print(client.Existed(context.Background(), value0, value1))
    fmt.Print("\n")
    break
  case "getListAll":
    if flag.NArg() - 1 != 1 {
      fmt.Fprintln(os.Stderr, "GetListAll requires 1 args")
      flag.Usage()
    }
    argvalue0, err95 := (strconv.ParseInt(flag.Arg(1), 10, 64))
    if err95 != nil {
      Usage()
      return
    }
    value0 := i64listi64.TKey(argvalue0)
    fmt.Print(client.GetListAll(context.Background(), value0))
    fmt.Print("\n")
    break
  case "getAll":
    if flag.NArg() - 1 != 1 {
      fmt.Fprintln(os.Stderr, "GetAll requires 1 args")
      flag.Usage()
    }
    argvalue0, err96 := (strconv.ParseInt(flag.Arg(1), 10, 64))
    if err96 != nil {
      Usage()
      return
    }
    value0 := i64listi64.TKey(argvalue0)
    fmt.Print(client.GetAll(context.Background(), value0))
    fmt.Print("\n")
    break
  case "getSlice":
    if flag.NArg() - 1 != 3 {
      fmt.Fprintln(os.Stderr, "GetSlice requires 3 args")
      flag.Usage()
    }
    argvalue0, err97 := (strconv.ParseInt(flag.Arg(1), 10, 64))
    if err97 != nil {
      Usage()
      return
    }
    value0 := i64listi64.TKey(argvalue0)
    tmp1, err98 := (strconv.Atoi(flag.Arg(2)))
    if err98 != nil {
      Usage()
      return
    }
    argvalue1 := int32(tmp1)
    value1 := argvalue1
    tmp2, err99 := (strconv.Atoi(flag.Arg(3)))
    if err99 != nil {
      Usage()
      return
    }
    argvalue2 := int32(tmp2)
    value2 := argvalue2
    fmt.Print(client.GetSlice(context.Background(), value0, value1, value2))
    fmt.Print("\n")
    break
  case "getSliceFromEntry":
    if flag.NArg() - 1 != 3 {
      fmt.Fprintln(os.Stderr, "GetSliceFromEntry requires 3 args")
      flag.Usage()
    }
    argvalue0, err100 := (strconv.ParseInt(flag.Arg(1), 10, 64))
    if err100 != nil {
      Usage()
      return
    }
    value0 := i64listi64.TKey(argvalue0)
    argvalue1, err101 := (strconv.ParseInt(flag.Arg(2), 10, 64))
    if err101 != nil {
      Usage()
      return
    }
    value1 := i64listi64.TEntry(argvalue1)
    tmp2, err102 := (strconv.Atoi(flag.Arg(3)))
    if err102 != nil {
      Usage()
      return
    }
    argvalue2 := int32(tmp2)
    value2 := argvalue2
    fmt.Print(client.GetSliceFromEntry(context.Background(), value0, value1, value2))
    fmt.Print("\n")
    break
  case "getSliceFromId":
    if flag.NArg() - 1 != 3 {
      fmt.Fprintln(os.Stderr, "GetSliceFromId requires 3 args")
      flag.Usage()
    }
    argvalue0, err103 := (strconv.ParseInt(flag.Arg(1), 10, 64))
    if err103 != nil {
      Usage()
      return
    }
    value0 := i64listi64.TKey(argvalue0)
    argvalue1, err104 := (strconv.ParseInt(flag.Arg(2), 10, 64))
    if err104 != nil {
      Usage()
      return
    }
    value1 := i64listi64.TEntry(argvalue1)
    tmp2, err105 := (strconv.Atoi(flag.Arg(3)))
    if err105 != nil {
      Usage()
      return
    }
    argvalue2 := int32(tmp2)
    value2 := argvalue2
    fmt.Print(client.GetSliceFromId(context.Background(), value0, value1, value2))
    fmt.Print("\n")
    break
  case "getSliceReverse":
    if flag.NArg() - 1 != 3 {
      fmt.Fprintln(os.Stderr, "GetSliceReverse requires 3 args")
      flag.Usage()
    }
    argvalue0, err106 := (strconv.ParseInt(flag.Arg(1), 10, 64))
    if err106 != nil {
      Usage()
      return
    }
    value0 := i64listi64.TKey(argvalue0)
    tmp1, err107 := (strconv.Atoi(flag.Arg(2)))
    if err107 != nil {
      Usage()
      return
    }
    argvalue1 := int32(tmp1)
    value1 := argvalue1
    tmp2, err108 := (strconv.Atoi(flag.Arg(3)))
    if err108 != nil {
      Usage()
      return
    }
    argvalue2 := int32(tmp2)
    value2 := argvalue2
    fmt.Print(client.GetSliceReverse(context.Background(), value0, value1, value2))
    fmt.Print("\n")
    break
  case "getSliceFromEntryReverse":
    if flag.NArg() - 1 != 3 {
      fmt.Fprintln(os.Stderr, "GetSliceFromEntryReverse requires 3 args")
      flag.Usage()
    }
    argvalue0, err109 := (strconv.ParseInt(flag.Arg(1), 10, 64))
    if err109 != nil {
      Usage()
      return
    }
    value0 := i64listi64.TKey(argvalue0)
    argvalue1, err110 := (strconv.ParseInt(flag.Arg(2), 10, 64))
    if err110 != nil {
      Usage()
      return
    }
    value1 := i64listi64.TEntry(argvalue1)
    tmp2, err111 := (strconv.Atoi(flag.Arg(3)))
    if err111 != nil {
      Usage()
      return
    }
    argvalue2 := int32(tmp2)
    value2 := argvalue2
    fmt.Print(client.GetSliceFromEntryReverse(context.Background(), value0, value1, value2))
    fmt.Print("\n")
    break
  case "getSliceFromIdReverse":
    if flag.NArg() - 1 != 3 {
      fmt.Fprintln(os.Stderr, "GetSliceFromIdReverse requires 3 args")
      flag.Usage()
    }
    argvalue0, err112 := (strconv.ParseInt(flag.Arg(1), 10, 64))
    if err112 != nil {
      Usage()
      return
    }
    value0 := i64listi64.TKey(argvalue0)
    argvalue1, err113 := (strconv.ParseInt(flag.Arg(2), 10, 64))
    if err113 != nil {
      Usage()
      return
    }
    value1 := i64listi64.TEntry(argvalue1)
    tmp2, err114 := (strconv.Atoi(flag.Arg(3)))
    if err114 != nil {
      Usage()
      return
    }
    argvalue2 := int32(tmp2)
    value2 := argvalue2
    fmt.Print(client.GetSliceFromIdReverse(context.Background(), value0, value1, value2))
    fmt.Print("\n")
    break
  case "put":
    if flag.NArg() - 1 != 2 {
      fmt.Fprintln(os.Stderr, "Put requires 2 args")
      flag.Usage()
    }
    argvalue0, err115 := (strconv.ParseInt(flag.Arg(1), 10, 64))
    if err115 != nil {
      Usage()
      return
    }
    value0 := i64listi64.TKey(argvalue0)
    argvalue1, err116 := (strconv.ParseInt(flag.Arg(2), 10, 64))
    if err116 != nil {
      Usage()
      return
    }
    value1 := i64listi64.TEntry(argvalue1)
    fmt.Print(client.Put(context.Background(), value0, value1))
    fmt.Print("\n")
    break
  case "putValue":
    if flag.NArg() - 1 != 2 {
      fmt.Fprintln(os.Stderr, "PutValue requires 2 args")
      flag.Usage()
    }
    argvalue0, err117 := (strconv.ParseInt(flag.Arg(1), 10, 64))
    if err117 != nil {
      Usage()
      return
    }
    value0 := i64listi64.TKey(argvalue0)
    arg118 := flag.Arg(2)
    mbTrans119 := thrift.NewTMemoryBufferLen(len(arg118))
    defer mbTrans119.Close()
    _, err120 := mbTrans119.WriteString(arg118)
    if err120 != nil {
      Usage()
      return
    }
    factory121 := thrift.NewTSimpleJSONProtocolFactory()
    jsProt122 := factory121.GetProtocol(mbTrans119)
    argvalue1 := i64listi64.NewTValue()
    err123 := argvalue1.Read(jsProt122)
    if err123 != nil {
      Usage()
      return
    }
    value1 := argvalue1
    fmt.Print(client.PutValue(context.Background(), value0, value1))
    fmt.Print("\n")
    break
  case "putList":
    if flag.NArg() - 1 != 2 {
      fmt.Fprintln(os.Stderr, "PutList requires 2 args")
      flag.Usage()
    }
    argvalue0, err124 := (strconv.ParseInt(flag.Arg(1), 10, 64))
    if err124 != nil {
      Usage()
      return
    }
    value0 := i64listi64.TKey(argvalue0)
    arg125 := flag.Arg(2)
    mbTrans126 := thrift.NewTMemoryBufferLen(len(arg125))
    defer mbTrans126.Close()
    _, err127 := mbTrans126.WriteString(arg125)
    if err127 != nil { 
      Usage()
      return
    }
    factory128 := thrift.NewTSimpleJSONProtocolFactory()
    jsProt129 := factory128.GetProtocol(mbTrans126)
    containerStruct1 := i64listi64.NewI64ListI64ServicePutListArgs()
    err130 := containerStruct1.ReadField2(jsProt129)
    if err130 != nil {
      Usage()
      return
    }
    argvalue1 := containerStruct1.EntryList
    value1 := i64listi64.TEntryList(argvalue1)
    fmt.Print(client.PutList(context.Background(), value0, value1))
    fmt.Print("\n")
    break
  case "insert":
    if flag.NArg() - 1 != 2 {
      fmt.Fprintln(os.Stderr, "Insert requires 2 args")
      flag.Usage()
    }
    argvalue0, err131 := (strconv.ParseInt(flag.Arg(1), 10, 64))
    if err131 != nil {
      Usage()
      return
    }
    value0 := i64listi64.TKey(argvalue0)
    argvalue1, err132 := (strconv.ParseInt(flag.Arg(2), 10, 64))
    if err132 != nil {
      Usage()
      return
    }
    value1 := i64listi64.TEntry(argvalue1)
    fmt.Print(client.Insert(context.Background(), value0, value1))
    fmt.Print("\n")
    break
  case "insertAt":
    if flag.NArg() - 1 != 3 {
      fmt.Fprintln(os.Stderr, "InsertAt requires 3 args")
      flag.Usage()
    }
    argvalue0, err133 := (strconv.ParseInt(flag.Arg(1), 10, 64))
    if err133 != nil {
      Usage()
      return
    }
    value0 := i64listi64.TKey(argvalue0)
    argvalue1, err134 := (strconv.ParseInt(flag.Arg(2), 10, 64))
    if err134 != nil {
      Usage()
      return
    }
    value1 := i64listi64.TEntry(argvalue1)
    tmp2, err135 := (strconv.Atoi(flag.Arg(3)))
    if err135 != nil {
      Usage()
      return
    }
    argvalue2 := int32(tmp2)
    value2 := argvalue2
    fmt.Print(client.InsertAt(context.Background(), value0, value1, value2))
    fmt.Print("\n")
    break
  case "remove":
    if flag.NArg() - 1 != 2 {
      fmt.Fprintln(os.Stderr, "Remove requires 2 args")
      flag.Usage()
    }
    argvalue0, err136 := (strconv.ParseInt(flag.Arg(1), 10, 64))
    if err136 != nil {
      Usage()
      return
    }
    value0 := i64listi64.TKey(argvalue0)
    argvalue1, err137 := (strconv.ParseInt(flag.Arg(2), 10, 64))
    if err137 != nil {
      Usage()
      return
    }
    value1 := i64listi64.TEntry(argvalue1)
    fmt.Print(client.Remove(context.Background(), value0, value1))
    fmt.Print("\n")
    break
  case "removeAt":
    if flag.NArg() - 1 != 2 {
      fmt.Fprintln(os.Stderr, "RemoveAt requires 2 args")
      flag.Usage()
    }
    argvalue0, err138 := (strconv.ParseInt(flag.Arg(1), 10, 64))
    if err138 != nil {
      Usage()
      return
    }
    value0 := i64listi64.TKey(argvalue0)
    tmp1, err139 := (strconv.Atoi(flag.Arg(2)))
    if err139 != nil {
      Usage()
      return
    }
    argvalue1 := int32(tmp1)
    value1 := argvalue1
    fmt.Print(client.RemoveAt(context.Background(), value0, value1))
    fmt.Print("\n")
    break
  case "bumpUp":
    if flag.NArg() - 1 != 2 {
      fmt.Fprintln(os.Stderr, "BumpUp requires 2 args")
      flag.Usage()
    }
    argvalue0, err140 := (strconv.ParseInt(flag.Arg(1), 10, 64))
    if err140 != nil {
      Usage()
      return
    }
    value0 := i64listi64.TKey(argvalue0)
    argvalue1, err141 := (strconv.ParseInt(flag.Arg(2), 10, 64))
    if err141 != nil {
      Usage()
      return
    }
    value1 := i64listi64.TEntry(argvalue1)
    fmt.Print(client.BumpUp(context.Background(), value0, value1))
    fmt.Print("\n")
    break
  case "removeList":
    if flag.NArg() - 1 != 2 {
      fmt.Fprintln(os.Stderr, "RemoveList requires 2 args")
      flag.Usage()
    }
    argvalue0, err142 := (strconv.ParseInt(flag.Arg(1), 10, 64))
    if err142 != nil {
      Usage()
      return
    }
    value0 := i64listi64.TKey(argvalue0)
    arg143 := flag.Arg(2)
    mbTrans144 := thrift.NewTMemoryBufferLen(len(arg143))
    defer mbTrans144.Close()
    _, err145 := mbTrans144.WriteString(arg143)
    if err145 != nil { 
      Usage()
      return
    }
    factory146 := thrift.NewTSimpleJSONProtocolFactory()
    jsProt147 := factory146.GetProtocol(mbTrans144)
    containerStruct1 := i64listi64.NewI64ListI64ServiceRemoveListArgs()
    err148 := containerStruct1.ReadField2(jsProt147)
    if err148 != nil {
      Usage()
      return
    }
    argvalue1 := containerStruct1.EntryList
    value1 := i64listi64.TEntryList(argvalue1)
    fmt.Print(client.RemoveList(context.Background(), value0, value1))
    fmt.Print("\n")
    break
  case "clearData":
    if flag.NArg() - 1 != 1 {
      fmt.Fprintln(os.Stderr, "ClearData requires 1 args")
      flag.Usage()
    }
    argvalue0, err149 := (strconv.ParseInt(flag.Arg(1), 10, 64))
    if err149 != nil {
      Usage()
      return
    }
    value0 := i64listi64.TKey(argvalue0)
    fmt.Print(client.ClearData(context.Background(), value0))
    fmt.Print("\n")
    break
  case "split":
    if flag.NArg() - 1 != 3 {
      fmt.Fprintln(os.Stderr, "Split requires 3 args")
      flag.Usage()
    }
    argvalue0, err150 := (strconv.ParseInt(flag.Arg(1), 10, 64))
    if err150 != nil {
      Usage()
      return
    }
    value0 := i64listi64.TKey(argvalue0)
    argvalue1, err151 := (strconv.ParseInt(flag.Arg(2), 10, 64))
    if err151 != nil {
      Usage()
      return
    }
    value1 := i64listi64.TKey(argvalue1)
    tmp2, err152 := (strconv.Atoi(flag.Arg(3)))
    if err152 != nil {
      Usage()
      return
    }
    argvalue2 := int32(tmp2)
    value2 := argvalue2
    fmt.Print(client.Split(context.Background(), value0, value1, value2))
    fmt.Print("\n")
    break
  case "multiCount":
    if flag.NArg() - 1 != 1 {
      fmt.Fprintln(os.Stderr, "MultiCount requires 1 args")
      flag.Usage()
    }
    arg153 := flag.Arg(1)
    mbTrans154 := thrift.NewTMemoryBufferLen(len(arg153))
    defer mbTrans154.Close()
    _, err155 := mbTrans154.WriteString(arg153)
    if err155 != nil { 
      Usage()
      return
    }
    factory156 := thrift.NewTSimpleJSONProtocolFactory()
    jsProt157 := factory156.GetProtocol(mbTrans154)
    containerStruct0 := i64listi64.NewI64ListI64ServiceMultiCountArgs()
    err158 := containerStruct0.ReadField1(jsProt157)
    if err158 != nil {
      Usage()
      return
    }
    argvalue0 := containerStruct0.KeyList
    value0 := i64listi64.TKeyList(argvalue0)
    fmt.Print(client.MultiCount(context.Background(), value0))
    fmt.Print("\n")
    break
  case "multiExisted":
    if flag.NArg() - 1 != 2 {
      fmt.Fprintln(os.Stderr, "MultiExisted requires 2 args")
      flag.Usage()
    }
    arg159 := flag.Arg(1)
    mbTrans160 := thrift.NewTMemoryBufferLen(len(arg159))
    defer mbTrans160.Close()
    _, err161 := mbTrans160.WriteString(arg159)
    if err161 != nil { 
      Usage()
      return
    }
    factory162 := thrift.NewTSimpleJSONProtocolFactory()
    jsProt163 := factory162.GetProtocol(mbTrans160)
    containerStruct0 := i64listi64.NewI64ListI64ServiceMultiExistedArgs()
    err164 := containerStruct0.ReadField1(jsProt163)
    if err164 != nil {
      Usage()
      return
    }
    argvalue0 := containerStruct0.KeyList
    value0 := i64listi64.TKeyList(argvalue0)
    argvalue1, err165 := (strconv.ParseInt(flag.Arg(2), 10, 64))
    if err165 != nil {
      Usage()
      return
    }
    value1 := i64listi64.TEntry(argvalue1)
    fmt.Print(client.MultiExisted(context.Background(), value0, value1))
    fmt.Print("\n")
    break
  case "multiGetListAll":
    if flag.NArg() - 1 != 1 {
      fmt.Fprintln(os.Stderr, "MultiGetListAll requires 1 args")
      flag.Usage()
    }
    arg166 := flag.Arg(1)
    mbTrans167 := thrift.NewTMemoryBufferLen(len(arg166))
    defer mbTrans167.Close()
    _, err168 := mbTrans167.WriteString(arg166)
    if err168 != nil { 
      Usage()
      return
    }
    factory169 := thrift.NewTSimpleJSONProtocolFactory()
    jsProt170 := factory169.GetProtocol(mbTrans167)
    containerStruct0 := i64listi64.NewI64ListI64ServiceMultiGetListAllArgs()
    err171 := containerStruct0.ReadField1(jsProt170)
    if err171 != nil {
      Usage()
      return
    }
    argvalue0 := containerStruct0.KeyList
    value0 := i64listi64.TKeyList(argvalue0)
    fmt.Print(client.MultiGetListAll(context.Background(), value0))
    fmt.Print("\n")
    break
  case "multiGetSlice":
    if flag.NArg() - 1 != 3 {
      fmt.Fprintln(os.Stderr, "MultiGetSlice requires 3 args")
      flag.Usage()
    }
    arg172 := flag.Arg(1)
    mbTrans173 := thrift.NewTMemoryBufferLen(len(arg172))
    defer mbTrans173.Close()
    _, err174 := mbTrans173.WriteString(arg172)
    if err174 != nil { 
      Usage()
      return
    }
    factory175 := thrift.NewTSimpleJSONProtocolFactory()
    jsProt176 := factory175.GetProtocol(mbTrans173)
    containerStruct0 := i64listi64.NewI64ListI64ServiceMultiGetSliceArgs()
    err177 := containerStruct0.ReadField1(jsProt176)
    if err177 != nil {
      Usage()
      return
    }
    argvalue0 := containerStruct0.KeyList
    value0 := i64listi64.TKeyList(argvalue0)
    tmp1, err178 := (strconv.Atoi(flag.Arg(2)))
    if err178 != nil {
      Usage()
      return
    }
    argvalue1 := int32(tmp1)
    value1 := argvalue1
    tmp2, err179 := (strconv.Atoi(flag.Arg(3)))
    if err179 != nil {
      Usage()
      return
    }
    argvalue2 := int32(tmp2)
    value2 := argvalue2
    fmt.Print(client.MultiGetSlice(context.Background(), value0, value1, value2))
    fmt.Print("\n")
    break
  case "multiGetSliceReverse":
    if flag.NArg() - 1 != 3 {
      fmt.Fprintln(os.Stderr, "MultiGetSliceReverse requires 3 args")
      flag.Usage()
    }
    arg180 := flag.Arg(1)
    mbTrans181 := thrift.NewTMemoryBufferLen(len(arg180))
    defer mbTrans181.Close()
    _, err182 := mbTrans181.WriteString(arg180)
    if err182 != nil { 
      Usage()
      return
    }
    factory183 := thrift.NewTSimpleJSONProtocolFactory()
    jsProt184 := factory183.GetProtocol(mbTrans181)
    containerStruct0 := i64listi64.NewI64ListI64ServiceMultiGetSliceReverseArgs()
    err185 := containerStruct0.ReadField1(jsProt184)
    if err185 != nil {
      Usage()
      return
    }
    argvalue0 := containerStruct0.KeyList
    value0 := i64listi64.TKeyList(argvalue0)
    tmp1, err186 := (strconv.Atoi(flag.Arg(2)))
    if err186 != nil {
      Usage()
      return
    }
    argvalue1 := int32(tmp1)
    value1 := argvalue1
    tmp2, err187 := (strconv.Atoi(flag.Arg(3)))
    if err187 != nil {
      Usage()
      return
    }
    argvalue2 := int32(tmp2)
    value2 := argvalue2
    fmt.Print(client.MultiGetSliceReverse(context.Background(), value0, value1, value2))
    fmt.Print("\n")
    break
  case "multiPut":
    if flag.NArg() - 1 != 2 {
      fmt.Fprintln(os.Stderr, "MultiPut requires 2 args")
      flag.Usage()
    }
    arg188 := flag.Arg(1)
    mbTrans189 := thrift.NewTMemoryBufferLen(len(arg188))
    defer mbTrans189.Close()
    _, err190 := mbTrans189.WriteString(arg188)
    if err190 != nil { 
      Usage()
      return
    }
    factory191 := thrift.NewTSimpleJSONProtocolFactory()
    jsProt192 := factory191.GetProtocol(mbTrans189)
    containerStruct0 := i64listi64.NewI64ListI64ServiceMultiPutArgs()
    err193 := containerStruct0.ReadField1(jsProt192)
    if err193 != nil {
      Usage()
      return
    }
    argvalue0 := containerStruct0.KeyList
    value0 := i64listi64.TKeyList(argvalue0)
    argvalue1, err194 := (strconv.ParseInt(flag.Arg(2), 10, 64))
    if err194 != nil {
      Usage()
      return
    }
    value1 := i64listi64.TEntry(argvalue1)
    fmt.Print(client.MultiPut(context.Background(), value0, value1))
    fmt.Print("\n")
    break
  case "put_ow":
    if flag.NArg() - 1 != 2 {
      fmt.Fprintln(os.Stderr, "PutOw requires 2 args")
      flag.Usage()
    }
    argvalue0, err195 := (strconv.ParseInt(flag.Arg(1), 10, 64))
    if err195 != nil {
      Usage()
      return
    }
    value0 := i64listi64.TKey(argvalue0)
    argvalue1, err196 := (strconv.ParseInt(flag.Arg(2), 10, 64))
    if err196 != nil {
      Usage()
      return
    }
    value1 := i64listi64.TEntry(argvalue1)
    fmt.Print(client.PutOw(context.Background(), value0, value1))
    fmt.Print("\n")
    break
  case "putMultiKey_ow":
    if flag.NArg() - 1 != 2 {
      fmt.Fprintln(os.Stderr, "PutMultiKeyOw requires 2 args")
      flag.Usage()
    }
    arg197 := flag.Arg(1)
    mbTrans198 := thrift.NewTMemoryBufferLen(len(arg197))
    defer mbTrans198.Close()
    _, err199 := mbTrans198.WriteString(arg197)
    if err199 != nil { 
      Usage()
      return
    }
    factory200 := thrift.NewTSimpleJSONProtocolFactory()
    jsProt201 := factory200.GetProtocol(mbTrans198)
    containerStruct0 := i64listi64.NewI64ListI64ServicePutMultiKeyOwArgs()
    err202 := containerStruct0.ReadField1(jsProt201)
    if err202 != nil {
      Usage()
      return
    }
    argvalue0 := containerStruct0.UidList
    value0 := i64listi64.TKeyList(argvalue0)
    argvalue1, err203 := (strconv.ParseInt(flag.Arg(2), 10, 64))
    if err203 != nil {
      Usage()
      return
    }
    value1 := i64listi64.TEntry(argvalue1)
    fmt.Print(client.PutMultiKeyOw(context.Background(), value0, value1))
    fmt.Print("\n")
    break
  case "remove_ow":
    if flag.NArg() - 1 != 2 {
      fmt.Fprintln(os.Stderr, "RemoveOw requires 2 args")
      flag.Usage()
    }
    argvalue0, err204 := (strconv.ParseInt(flag.Arg(1), 10, 64))
    if err204 != nil {
      Usage()
      return
    }
    value0 := i64listi64.TKey(argvalue0)
    argvalue1, err205 := (strconv.ParseInt(flag.Arg(2), 10, 64))
    if err205 != nil {
      Usage()
      return
    }
    value1 := i64listi64.TEntry(argvalue1)
    fmt.Print(client.RemoveOw(context.Background(), value0, value1))
    fmt.Print("\n")
    break
  case "":
    Usage()
    break
  default:
    fmt.Fprintln(os.Stderr, "Invalid function ", cmd)
  }
}
